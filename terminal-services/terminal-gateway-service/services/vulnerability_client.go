package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"terminal-gateway-service/models"
)

// VulnerabilityClient provides methods to interact with the attack-vulnerability-service
type VulnerabilityClient struct {
	baseURL    string
	httpClient *http.Client
	authToken  string
	retryConfig RetryConfig
}

// NewVulnerabilityClient creates a new client for the attack-vulnerability-service
func NewVulnerabilityClient(baseURL string, timeout time.Duration) *VulnerabilityClient {
	return &VulnerabilityClient{
		baseURL: baseURL,
		httpClient: &http.Client{
			Timeout: timeout,
			Transport: &http.Transport{
				MaxIdleConns:        10,
				IdleConnTimeout:     30 * time.Second,
				DisableCompression:  false,
				MaxConnsPerHost:     10,
			},
		},
		retryConfig: RetryConfig{
			MaxRetries:  3,
			InitialWait: 100 * time.Millisecond,
			MaxWait:     2 * time.Second,
		},
	}
}

// SetAuthToken sets the authentication token for the client
func (c *VulnerabilityClient) SetAuthToken(token string) {
	c.authToken = token
}

// CheckVulnerabilities sends a request to check for vulnerabilities
func (c *VulnerabilityClient) CheckVulnerabilities(
	sessionID string, 
	osInfo models.OSInfo, 
	softwareList []models.SoftwareInfo,
) (*models.VulnerabilityCheckResponse, error) {
	url := fmt.Sprintf("%s/api/v1/check", c.baseURL)
	
	// Create request data
	requestData := models.VulnerabilityCheckRequest{
		SessionID:    sessionID,
		OSInfo:       osInfo,
		SoftwareList: softwareList,
	}
	
	// Marshal to JSON
	jsonData, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal vulnerability check request: %w", err)
	}
	
	// Create HTTP request
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.authToken != "" {
		req.Header.Set("X-API-Key", c.authToken)
	}
	
	// Send request with retry
	resp, err := c.doWithRetry(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()
	
	// Handle error responses
	if resp.StatusCode >= 400 {
		var errorResp struct {
			Detail string `json:"detail"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&errorResp); err == nil && errorResp.Detail != "" {
			return nil, fmt.Errorf("vulnerability service error: %s", errorResp.Detail)
		}
		return nil, fmt.Errorf("vulnerability service returned error: %s", resp.Status)
	}
	
	// Parse response
	var response models.VulnerabilityCheckResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode vulnerability response: %w", err)
	}
	
	return &response, nil
}

// GetSessionVulnerabilities gets vulnerabilities for a specific session
func (c *VulnerabilityClient) GetSessionVulnerabilities(sessionID string) (*models.VulnerabilityCheckResponse, error) {
	url := fmt.Sprintf("%s/api/v1/sessions/%s/vulnerabilities", c.baseURL, sessionID)
	
	// Create HTTP request
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	// Set headers
	if c.authToken != "" {
		req.Header.Set("X-API-Key", c.authToken)
	}
	
	// Send request with retry
	resp, err := c.doWithRetry(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()
	
	// Handle error responses
	if resp.StatusCode >= 400 {
		if resp.StatusCode == http.StatusNotFound {
			return nil, fmt.Errorf("no vulnerability data found for session %s", sessionID)
		}
		
		var errorResp struct {
			Detail string `json:"detail"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&errorResp); err == nil && errorResp.Detail != "" {
			return nil, fmt.Errorf("vulnerability service error: %s", errorResp.Detail)
		}
		return nil, fmt.Errorf("vulnerability service returned error: %s", resp.Status)
	}
	
	// Parse response
	var response models.VulnerabilityCheckResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode vulnerability response: %w", err)
	}
	
	return &response, nil
}

// GetTechniqueDetails gets details for a specific MITRE ATT&CK technique
func (c *VulnerabilityClient) GetTechniqueDetails(techniqueID string) (map[string]interface{}, error) {
	url := fmt.Sprintf("%s/api/v1/techniques/%s", c.baseURL, techniqueID)
	
	// Create HTTP request
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	
	// Set headers
	if c.authToken != "" {
		req.Header.Set("X-API-Key", c.authToken)
	}
	
	// Send request with retry
	resp, err := c.doWithRetry(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()
	
	// Handle error responses
	if resp.StatusCode >= 400 {
		if resp.StatusCode == http.StatusNotFound {
			return nil, fmt.Errorf("technique %s not found", techniqueID)
		}
		
		var errorResp struct {
			Detail string `json:"detail"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&errorResp); err == nil && errorResp.Detail != "" {
			return nil, fmt.Errorf("vulnerability service error: %s", errorResp.Detail)
		}
		return nil, fmt.Errorf("vulnerability service returned error: %s", resp.Status)
	}
	
	// Parse response
	var response map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode technique details: %w", err)
	}
	
	return response, nil
}

// doWithRetry performs an HTTP request with retry logic
func (c *VulnerabilityClient) doWithRetry(req *http.Request) (*http.Response, error) {
	// Reuse SessionClient's doWithRetry implementation
	sessionClient := &SessionClient{
		baseURL:     c.baseURL,
		httpClient:  c.httpClient,
		retryConfig: c.retryConfig,
	}
	return sessionClient.doWithRetry(req)
}