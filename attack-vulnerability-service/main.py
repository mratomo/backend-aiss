"""Main application module for the attack-vulnerability-service."""

import logging
from typing import Dict, List, Optional, Any

from fastapi import Depends, FastAPI, HTTPException, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from config.settings import Settings
from models.vulnerability import (
    OSInfo,
    SoftwareInfo,
    Vulnerability,
    VulnerabilityCheckRequest,
    VulnerabilityCheckResponse,
)
from services.attackcti_service import AttackCTIService
from services.vulnerability_service import VulnerabilityService
from services.mcp_service import MCPService


# Initialize settings
settings = Settings()

# Configure logging
logging.basicConfig(
    level=getattr(logging, settings.log_level),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title=settings.app_name,
    description="Vulnerability checking service using MITRE ATT&CK data",
    version="1.0.0",
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize services
attackcti_service = AttackCTIService(settings)
mcp_service = MCPService(settings)
vulnerability_service = VulnerabilityService(attackcti_service, mcp_service, settings)


# Authentication dependency
async def verify_api_key(
    request: Request, x_api_key: Optional[str] = Header(None)
) -> None:
    """Verify API key if authentication is enabled.
    
    Args:
        request: FastAPI request
        x_api_key: API key from header
        
    Raises:
        HTTPException: If API key is invalid
    """
    if not settings.auth_enabled:
        return
    
    if not x_api_key:
        raise HTTPException(
            status_code=401,
            detail="API key is required",
            headers={"WWW-Authenticate": f"{settings.api_key_header}"},
        )
    
    if x_api_key != settings.api_key:
        raise HTTPException(
            status_code=403,
            detail="Invalid API key",
            headers={"WWW-Authenticate": f"{settings.api_key_header}"},
        )


@app.get("/health")
async def health_check() -> Dict[str, str]:
    """Health check endpoint.
    
    Returns:
        JSON response with status
    """
    return {"status": "ok", "service": settings.app_name}


@app.post(
    "/api/v1/check",
    response_model=VulnerabilityCheckResponse,
    dependencies=[Depends(verify_api_key)],
)
async def check_vulnerabilities(
    request: VulnerabilityCheckRequest,
) -> VulnerabilityCheckResponse:
    """Check for vulnerabilities in the provided software.
    
    Args:
        request: Vulnerability check request
        
    Returns:
        Vulnerability check response
    """
    try:
        logger.info(f"Received vulnerability check request for session {request.session_id}")
        return await vulnerability_service.check_vulnerabilities(request)
    except Exception as e:
        logger.error(f"Error checking vulnerabilities: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error checking vulnerabilities: {str(e)}",
        )


@app.get(
    "/api/v1/sessions/{session_id}/vulnerabilities",
    response_model=Optional[VulnerabilityCheckResponse],
    dependencies=[Depends(verify_api_key)],
)
async def get_session_vulnerabilities(
    session_id: str,
) -> Optional[VulnerabilityCheckResponse]:
    """Get vulnerabilities for a specific session.
    
    Args:
        session_id: Terminal session ID
        
    Returns:
        Vulnerability check response if found
        
    Raises:
        HTTPException: If session not found
    """
    try:
        result = await vulnerability_service.get_session_vulnerabilities(session_id)
        if not result:
            raise HTTPException(
                status_code=404,
                detail=f"No vulnerability data found for session {session_id}",
            )
        return result
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting session vulnerabilities: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error getting session vulnerabilities: {str(e)}",
        )


@app.get(
    "/api/v1/techniques/{technique_id}",
    dependencies=[Depends(verify_api_key)],
)
async def get_technique_details(technique_id: str) -> Dict[str, Any]:
    """Get detailed information about a technique.
    
    Args:
        technique_id: MITRE ATT&CK technique ID
        
    Returns:
        Technique details
        
    Raises:
        HTTPException: If technique not found
    """
    try:
        result = await vulnerability_service.get_technique_details(technique_id)
        if not result:
            raise HTTPException(
                status_code=404,
                detail=f"Technique {technique_id} not found",
            )
        return result
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting technique details: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error getting technique details: {str(e)}",
        )


@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Global exception handler.
    
    Args:
        request: FastAPI request
        exc: Exception
        
    Returns:
        JSON response with error details
    """
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": f"Internal server error: {str(exc)}"},
    )


if __name__ == "__main__":
    import uvicorn

    logger.info(f"Starting {settings.app_name} on {settings.host}:{settings.port}")
    uvicorn.run(
        "main:app",
        host=settings.host,
        port=settings.port,
        reload=settings.debug,
    )