"""Service for analyzing software vulnerabilities using MITRE ATT&CK data."""

import logging
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any

from models.vulnerability import (
    OSInfo,
    SoftwareInfo,
    Vulnerability,
    VulnerabilityCheckRequest,
    VulnerabilityCheckResponse,
    VulnerabilitySummary,
    SeverityLevel,
)
from services.attackcti_service import AttackCTIService
from config.settings import Settings

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service for analyzing software vulnerabilities."""

    def __init__(self, attackcti_service: AttackCTIService, settings: Settings):
        """Initialize the service.
        
        Args:
            attackcti_service: ATT&CK CTI service
            settings: Application settings
        """
        self.attackcti_service = attackcti_service
        self.settings = settings
        self.session_vulns: Dict[str, VulnerabilityCheckResponse] = {}
    
    async def check_vulnerabilities(
        self, request: VulnerabilityCheckRequest
    ) -> VulnerabilityCheckResponse:
        """Check for vulnerabilities in the provided software.
        
        Args:
            request: Vulnerability check request
            
        Returns:
            Vulnerability check response
        """
        logger.info(
            f"Checking vulnerabilities for session {request.session_id} - "
            f"OS: {request.os_info.type} {request.os_info.version or ''}, "
            f"{len(request.software_list)} software items"
        )
        
        vulnerabilities: List[Vulnerability] = []
        
        # Check OS vulnerabilities
        os_vulnerabilities = await self._check_os_vulnerabilities(request.os_info)
        vulnerabilities.extend(os_vulnerabilities)
        
        # Check software vulnerabilities
        for software in request.software_list:
            software_vulnerabilities = await self._check_software_vulnerabilities(software)
            vulnerabilities.extend(software_vulnerabilities)
        
        # Apply limit if needed
        max_vulns = self.settings.max_vulnerabilities_per_report
        if max_vulns > 0 and len(vulnerabilities) > max_vulns:
            # Sort by severity (high to low) and confidence (high to low)
            vulnerabilities.sort(
                key=lambda v: (
                    0 if v.severity == SeverityLevel.HIGH else
                    1 if v.severity == SeverityLevel.MEDIUM else
                    2 if v.severity == SeverityLevel.LOW else 3,
                    -v.confidence
                )
            )
            vulnerabilities = vulnerabilities[:max_vulns]
        
        # Create summary
        summary = self._create_vulnerability_summary(vulnerabilities)
        
        # Create response
        response = VulnerabilityCheckResponse(
            session_id=request.session_id,
            vulnerabilities=vulnerabilities,
            summary=summary,
            scan_timestamp=datetime.utcnow(),
        )
        
        # Store response for this session
        self.session_vulns[request.session_id] = response
        
        return response
    
    async def get_session_vulnerabilities(self, session_id: str) -> Optional[VulnerabilityCheckResponse]:
        """Get vulnerabilities for a specific session.
        
        Args:
            session_id: Terminal session ID
            
        Returns:
            Vulnerability response or None if not found
        """
        return self.session_vulns.get(session_id)
    
    async def get_technique_details(self, technique_id: str) -> Dict[str, Any]:
        """Get detailed information about a technique.
        
        Args:
            technique_id: MITRE ATT&CK technique ID
            
        Returns:
            Technique details
        """
        return self.attackcti_service.get_technique_details(technique_id)
    
    async def _check_os_vulnerabilities(self, os_info: OSInfo) -> List[Vulnerability]:
        """Check for vulnerabilities in the operating system.
        
        Args:
            os_info: Operating system information
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []
        
        # Handle the OS name based on type
        os_search_names = []
        
        if os_info.type.lower() in ["windows", "microsoft windows"]:
            os_search_names.append("windows")
            # Add version-specific searches
            if os_info.version:
                if "10" in os_info.version:
                    os_search_names.append("windows 10")
                elif "11" in os_info.version:
                    os_search_names.append("windows 11")
                elif "2016" in os_info.version or "2019" in os_info.version:
                    os_search_names.append("windows server")
        
        elif os_info.type.lower() in ["linux", "gnu/linux"]:
            os_search_names.append("linux")
            # Add distribution-specific searches
            if os_info.distribution:
                if "ubuntu" in os_info.distribution.lower():
                    os_search_names.append("ubuntu")
                elif "debian" in os_info.distribution.lower():
                    os_search_names.append("debian")
                elif "red hat" in os_info.distribution.lower() or "rhel" in os_info.distribution.lower():
                    os_search_names.append("red hat")
                    os_search_names.append("rhel")
                elif "centos" in os_info.distribution.lower():
                    os_search_names.append("centos")
        
        elif os_info.type.lower() in ["macos", "darwin", "mac os"]:
            os_search_names.append("macos")
            os_search_names.append("osx")
        
        # Search for vulnerabilities for each name
        for os_name in os_search_names:
            raw_vulnerabilities = self.attackcti_service.find_vulnerabilities_by_software(
                os_name, os_info.version
            )
            
            # Convert raw vulnerabilities to Vulnerability model
            for raw_vuln in raw_vulnerabilities:
                try:
                    vulnerability = Vulnerability(
                        id=raw_vuln["id"],
                        title=raw_vuln["title"],
                        description=raw_vuln["description"],
                        severity=SeverityLevel(raw_vuln["severity"]),
                        confidence=raw_vuln.get("confidence", 0.8),
                        affected_software=raw_vuln["affected_software"],
                        affected_version=raw_vuln.get("affected_version"),
                        mitre_technique_id=raw_vuln.get("mitre_technique_id"),
                        mitre_technique_name=raw_vuln.get("mitre_technique_name"),
                        mitre_tactic=raw_vuln.get("mitre_tactic"),
                        mitigation=raw_vuln.get("mitigation"),
                        reference_urls=raw_vuln.get("reference_urls", []),
                    )
                    vulnerabilities.append(vulnerability)
                except Exception as e:
                    logger.error(f"Error converting vulnerability: {e}")
        
        logger.info(f"Found {len(vulnerabilities)} OS vulnerabilities")
        return vulnerabilities
    
    async def _check_software_vulnerabilities(self, software: SoftwareInfo) -> List[Vulnerability]:
        """Check for vulnerabilities in a specific software.
        
        Args:
            software: Software information
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []
        
        # Skip OS checks (handled separately)
        if software.type.lower() == "os":
            return []
        
        raw_vulnerabilities = self.attackcti_service.find_vulnerabilities_by_software(
            software.name, software.version
        )
        
        # Convert raw vulnerabilities to Vulnerability model
        for raw_vuln in raw_vulnerabilities:
            try:
                vulnerability = Vulnerability(
                    id=raw_vuln["id"],
                    title=raw_vuln["title"],
                    description=raw_vuln["description"],
                    severity=SeverityLevel(raw_vuln["severity"]),
                    confidence=raw_vuln.get("confidence", 0.8),
                    affected_software=raw_vuln["affected_software"],
                    affected_version=raw_vuln.get("affected_version"),
                    mitre_technique_id=raw_vuln.get("mitre_technique_id"),
                    mitre_technique_name=raw_vuln.get("mitre_technique_name"),
                    mitre_tactic=raw_vuln.get("mitre_tactic"),
                    mitigation=raw_vuln.get("mitigation"),
                    reference_urls=raw_vuln.get("reference_urls", []),
                )
                vulnerabilities.append(vulnerability)
            except Exception as e:
                logger.error(f"Error converting vulnerability: {e}")
        
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {software.name}")
        return vulnerabilities
    
    def _create_vulnerability_summary(self, vulnerabilities: List[Vulnerability]) -> VulnerabilitySummary:
        """Create a summary of vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Vulnerability summary
        """
        summary = VulnerabilitySummary(
            total=len(vulnerabilities)
        )
        
        # Count by severity
        for vuln in vulnerabilities:
            if vuln.severity == SeverityLevel.HIGH:
                summary.high_risk += 1
            elif vuln.severity == SeverityLevel.MEDIUM:
                summary.medium_risk += 1
            elif vuln.severity == SeverityLevel.LOW:
                summary.low_risk += 1
            elif vuln.severity == SeverityLevel.INFORMATIONAL:
                summary.informational += 1
        
        return summary