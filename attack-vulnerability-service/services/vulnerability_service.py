"""Service for analyzing software vulnerabilities using MITRE ATT&CK data."""

import logging
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any

from models.vulnerability import (
    OSInfo,
    SoftwareInfo,
    Vulnerability,
    VulnerabilityCheckRequest,
    VulnerabilityCheckResponse,
    VulnerabilitySummary,
    SeverityLevel,
)
from services.attackcti_service import AttackCTIService
from config.settings import Settings

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service for analyzing software vulnerabilities."""

    def __init__(self, attackcti_service: AttackCTIService, mcp_service, settings: Settings):
        """Initialize the service.
        
        Args:
            attackcti_service: ATT&CK CTI service
            mcp_service: MCP service for context and knowledge sharing
            settings: Application settings
        """
        self.attackcti_service = attackcti_service
        self.mcp_service = mcp_service
        self.settings = settings
        self.session_vulns: Dict[str, VulnerabilityCheckResponse] = {}
    
    async def check_vulnerabilities(
        self, request: VulnerabilityCheckRequest
    ) -> VulnerabilityCheckResponse:
        """Check for vulnerabilities in the provided software.
        
        Args:
            request: Vulnerability check request
            
        Returns:
            Vulnerability check response
        """
        logger.info(
            f"Checking vulnerabilities for session {request.session_id} - "
            f"OS: {request.os_info.type} {request.os_info.version or ''}, "
            f"{len(request.software_list)} software items"
        )
        
        vulnerabilities: List[Vulnerability] = []
        
        # Check OS vulnerabilities
        os_vulnerabilities = await self._check_os_vulnerabilities(request.os_info)
        vulnerabilities.extend(os_vulnerabilities)
        
        # Check software vulnerabilities
        for software in request.software_list:
            software_vulnerabilities = await self._check_software_vulnerabilities(software)
            vulnerabilities.extend(software_vulnerabilities)
        
        # Apply limit if needed
        max_vulns = self.settings.max_vulnerabilities_per_report
        if max_vulns > 0 and len(vulnerabilities) > max_vulns:
            # Sort by severity (high to low) and confidence (high to low)
            vulnerabilities.sort(
                key=lambda v: (
                    0 if v.severity == SeverityLevel.HIGH else
                    1 if v.severity == SeverityLevel.MEDIUM else
                    2 if v.severity == SeverityLevel.LOW else 3,
                    -v.confidence
                )
            )
            vulnerabilities = vulnerabilities[:max_vulns]
        
        # Create summary
        summary = self._create_vulnerability_summary(vulnerabilities)
        
        # Create response
        response = VulnerabilityCheckResponse(
            session_id=request.session_id,
            vulnerabilities=vulnerabilities,
            summary=summary,
            scan_timestamp=datetime.utcnow(),
        )
        
        # Store response for this session
        self.session_vulns[request.session_id] = response
        
        # Store vulnerability information in MCP for future reference and context
        try:
            # Only store if we have vulnerabilities to report
            if vulnerabilities and len(vulnerabilities) > 0:
                # Format the metadata
                metadata = {
                    "session_id": request.session_id,
                    "os_type": request.os_info.type,
                    "os_version": request.os_info.version,
                    "os_distribution": request.os_info.distribution,
                    "vulnerability_count": len(vulnerabilities),
                    "high_risk_count": summary.high_risk,
                    "medium_risk_count": summary.medium_risk,
                    "low_risk_count": summary.low_risk,
                    "scan_timestamp": response.scan_timestamp.isoformat(),
                    "content_type": "vulnerability_report"
                }
                
                # Format the vulnerability text information
                vulnerability_text = f"""
Vulnerability Report for Terminal Session: {request.session_id}
OS: {request.os_info.type} {request.os_info.version or ''} {request.os_info.distribution or ''}
Scan Date: {response.scan_timestamp.isoformat()}

Summary:
- Total vulnerabilities: {summary.total}
- High risk: {summary.high_risk}
- Medium risk: {summary.medium_risk}
- Low risk: {summary.low_risk}
- Informational: {summary.informational}

Software analyzed:
"""
                # Add software list
                for software in request.software_list:
                    vulnerability_text += f"- {software.name} {software.version or ''} ({software.type})\n"
                
                # Add top vulnerabilities (limit to 10 for text clarity)
                vulnerability_text += "\nTop Vulnerabilities:\n"
                
                # Sort by severity for display
                sorted_vulns = sorted(
                    vulnerabilities[:10], 
                    key=lambda v: (
                        0 if v.severity == SeverityLevel.HIGH else
                        1 if v.severity == SeverityLevel.MEDIUM else
                        2 if v.severity == SeverityLevel.LOW else 3
                    )
                )
                
                for i, vuln in enumerate(sorted_vulns):
                    vulnerability_text += f"""
{i+1}. {vuln.title} ({vuln.severity.value})
   ID: {vuln.id}
   Description: {vuln.description[:200]}{'...' if len(vuln.description) > 200 else ''}
   Affected Software: {', '.join(vuln.affected_software)}
   {'MITRE Technique: ' + (vuln.mitre_technique_id or 'N/A') if vuln.mitre_technique_id else ''}
"""
                
                # Store in MCP
                await self.mcp_service.store_document(vulnerability_text, metadata)
                logger.info(f"Stored vulnerability report in MCP for session {request.session_id}")
                
                # For high severity vulnerabilities, analyze with LLM if possible
                high_severity_vulns = [v for v in vulnerabilities if v.severity == SeverityLevel.HIGH]
                if high_severity_vulns:
                    for vuln in high_severity_vulns[:3]:  # Limit to top 3 to avoid too many calls
                        try:
                            await self.mcp_service.store_vulnerability_analysis(
                                vuln.id, 
                                vuln.title,
                                vuln.description,
                                vuln.mitigation or "No mitigation information available",
                                vuln.severity.value,
                                {
                                    "session_id": request.session_id,
                                    "mitre_technique_id": vuln.mitre_technique_id
                                }
                            )
                        except Exception as e:
                            logger.warning(f"Error storing vulnerability analysis in MCP: {e}")
                
            else:
                logger.info(f"No vulnerabilities to store in MCP for session {request.session_id}")
                
        except Exception as e:
            logger.error(f"Error storing vulnerability data in MCP: {e}")
        
        return response
    
    async def get_session_vulnerabilities(self, session_id: str) -> Optional[VulnerabilityCheckResponse]:
        """Get vulnerabilities for a specific session.
        
        Args:
            session_id: Terminal session ID
            
        Returns:
            Vulnerability response or None if not found
        """
        return self.session_vulns.get(session_id)
    
    async def get_technique_details(self, technique_id: str) -> Dict[str, Any]:
        """Get detailed information about a technique.
        
        Args:
            technique_id: MITRE ATT&CK technique ID
            
        Returns:
            Technique details
        """
        return self.attackcti_service.get_technique_details(technique_id)
    
    async def _check_os_vulnerabilities(self, os_info: OSInfo) -> List[Vulnerability]:
        """Check for vulnerabilities in the operating system.
        
        Args:
            os_info: Operating system information
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []
        
        # Handle the OS name based on type
        os_search_names = []
        
        if os_info.type.lower() in ["windows", "microsoft windows"]:
            os_search_names.append("windows")
            # Add version-specific searches
            if os_info.version:
                if "10" in os_info.version:
                    os_search_names.append("windows 10")
                elif "11" in os_info.version:
                    os_search_names.append("windows 11")
                elif "2016" in os_info.version or "2019" in os_info.version:
                    os_search_names.append("windows server")
        
        elif os_info.type.lower() in ["linux", "gnu/linux"]:
            os_search_names.append("linux")
            # Add distribution-specific searches
            if os_info.distribution:
                if "ubuntu" in os_info.distribution.lower():
                    os_search_names.append("ubuntu")
                elif "debian" in os_info.distribution.lower():
                    os_search_names.append("debian")
                elif "red hat" in os_info.distribution.lower() or "rhel" in os_info.distribution.lower():
                    os_search_names.append("red hat")
                    os_search_names.append("rhel")
                elif "centos" in os_info.distribution.lower():
                    os_search_names.append("centos")
        
        elif os_info.type.lower() in ["macos", "darwin", "mac os"]:
            os_search_names.append("macos")
            os_search_names.append("osx")
        
        # Search for vulnerabilities for each name
        for os_name in os_search_names:
            raw_vulnerabilities = self.attackcti_service.find_vulnerabilities_by_software(
                os_name, os_info.version
            )
            
            # Convert raw vulnerabilities to Vulnerability model
            for raw_vuln in raw_vulnerabilities:
                try:
                    vulnerability = Vulnerability(
                        id=raw_vuln["id"],
                        title=raw_vuln["title"],
                        description=raw_vuln["description"],
                        severity=SeverityLevel(raw_vuln["severity"]),
                        confidence=raw_vuln.get("confidence", 0.8),
                        affected_software=raw_vuln["affected_software"],
                        affected_version=raw_vuln.get("affected_version"),
                        mitre_technique_id=raw_vuln.get("mitre_technique_id"),
                        mitre_technique_name=raw_vuln.get("mitre_technique_name"),
                        mitre_tactic=raw_vuln.get("mitre_tactic"),
                        mitigation=raw_vuln.get("mitigation"),
                        reference_urls=raw_vuln.get("reference_urls", []),
                    )
                    vulnerabilities.append(vulnerability)
                except Exception as e:
                    logger.error(f"Error converting vulnerability: {e}")
        
        logger.info(f"Found {len(vulnerabilities)} OS vulnerabilities")
        return vulnerabilities
    
    async def _check_software_vulnerabilities(self, software: SoftwareInfo) -> List[Vulnerability]:
        """Check for vulnerabilities in a specific software.
        
        Args:
            software: Software information
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []
        
        # Skip OS checks (handled separately)
        if software.type.lower() == "os":
            return []
        
        raw_vulnerabilities = self.attackcti_service.find_vulnerabilities_by_software(
            software.name, software.version
        )
        
        # Convert raw vulnerabilities to Vulnerability model
        for raw_vuln in raw_vulnerabilities:
            try:
                vulnerability = Vulnerability(
                    id=raw_vuln["id"],
                    title=raw_vuln["title"],
                    description=raw_vuln["description"],
                    severity=SeverityLevel(raw_vuln["severity"]),
                    confidence=raw_vuln.get("confidence", 0.8),
                    affected_software=raw_vuln["affected_software"],
                    affected_version=raw_vuln.get("affected_version"),
                    mitre_technique_id=raw_vuln.get("mitre_technique_id"),
                    mitre_technique_name=raw_vuln.get("mitre_technique_name"),
                    mitre_tactic=raw_vuln.get("mitre_tactic"),
                    mitigation=raw_vuln.get("mitigation"),
                    reference_urls=raw_vuln.get("reference_urls", []),
                )
                vulnerabilities.append(vulnerability)
            except Exception as e:
                logger.error(f"Error converting vulnerability: {e}")
        
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities for {software.name}")
        return vulnerabilities
    
    def _create_vulnerability_summary(self, vulnerabilities: List[Vulnerability]) -> VulnerabilitySummary:
        """Create a summary of vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Vulnerability summary
        """
        summary = VulnerabilitySummary(
            total=len(vulnerabilities)
        )
        
        # Count by severity
        for vuln in vulnerabilities:
            if vuln.severity == SeverityLevel.HIGH:
                summary.high_risk += 1
            elif vuln.severity == SeverityLevel.MEDIUM:
                summary.medium_risk += 1
            elif vuln.severity == SeverityLevel.LOW:
                summary.low_risk += 1
            elif vuln.severity == SeverityLevel.INFORMATIONAL:
                summary.informational += 1
        
        return summary