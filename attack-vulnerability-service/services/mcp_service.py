# services/mcp_service.py
import logging
from typing import Dict, List, Optional, Any, Union
import httpx
from fastapi import HTTPException

# MCP library support with fallback
try:
    import mcp
    import fastmcp
    from mcp import Context, ContextType, Tool, Client
    from mcp.client import ClientError, ContextNotFoundError
    MCP_AVAILABLE = True
    logger = logging.getLogger(__name__)
    logger.info(f"MCP Python client library loaded successfully. Version: {getattr(mcp, '__version__', 'unknown')}")
except ImportError:
    logger = logging.getLogger(__name__)
    logger.warning("Official MCP Python client library not available. Using HTTP fallback implementation.")
    MCP_AVAILABLE = False

from config.settings import Settings

class MCPService:
    """Service for interacting with Model Context Protocol (MCP) v1.6.0"""

    def __init__(self, settings: Settings):
        """Initialize service with configuration"""
        self.settings = settings
        self.context_service_url = settings.mcp_service_url if hasattr(settings, 'mcp_service_url') else "http://context-service:8083"
        self.target_mcp_version = "1.6.0"
        
        # Initialize official MCP client if available
        self.mcp_client = None
        self.use_native_client = MCP_AVAILABLE
        
        if self.use_native_client:
            try:
                self.mcp_client = mcp.Client(base_url=f"{self.context_service_url}/api/v1/mcp")
                logger.info(f"MCP native client initialized with base URL: {self.context_service_url}/api/v1/mcp")
            except Exception as e:
                logger.error(f"Error initializing MCP native client: {e}")
                self.use_native_client = False
                
    async def _make_request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """
        Make a request to the MCP context service API using httpx
        (Fallback method when native client is not available)

        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            endpoint: API endpoint
            data: Request data (for POST, PUT)

        Returns:
            API response as dictionary
        """
        url = f"{self.context_service_url}/{endpoint}"
        headers = {"Content-Type": "application/json"}

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                if method == "GET":
                    response = await client.get(url, headers=headers)
                elif method == "POST":
                    response = await client.post(url, headers=headers, json=data)
                elif method == "PUT":
                    response = await client.put(url, headers=headers, json=data)
                elif method == "DELETE":
                    response = await client.delete(url, headers=headers, json=data)
                else:
                    raise ValueError(f"Unsupported HTTP method: {method}")
                
                if response.status_code >= 400:
                    error_text = response.text
                    logger.error(f"Error in MCP request {method} {url}: {response.status_code} - {error_text}")
                    raise HTTPException(status_code=response.status_code, detail=f"MCP error: {error_text}")
                
                return response.json()

        except httpx.RequestError as e:
            logger.error(f"Client error in MCP request {method} {url}: {str(e)}")
            raise HTTPException(status_code=502, detail=f"Connection error with MCP: {str(e)}")

    async def get_status(self) -> Dict:
        """
        Get MCP service status

        Returns:
            Status information
        """
        if self.use_native_client and self.mcp_client:
            try:
                # Use native MCP client method
                status = await self.mcp_client.get_status()
                return {
                    "name": status.name,
                    "version": status.version,
                    "tools": [t.dict() for t in status.tools] if hasattr(status, 'tools') else [],
                    "contexts_count": getattr(status, 'contexts_count', 0),
                    "active_contexts": getattr(status, 'active_contexts', 0),
                    "client_type": "native"
                }
            except Exception as e:
                logger.error(f"Error using native MCP client for get_status: {e}")
                # Fall back to HTTP implementation if error
        
        # Traditional HTTP method
        result = await self._make_request("GET", "api/v1/mcp/status")
        if isinstance(result, dict):
            result["client_type"] = "http"
        return result

    async def call_tool(self, tool_name: str, **params) -> Any:
        """
        Call an MCP tool with parameters

        Args:
            tool_name: Name of the tool to call
            **params: Tool parameters

        Returns:
            Tool result
        """
        if self.use_native_client and self.mcp_client:
            try:
                # Use native MCP client method to call tool
                result = await self.mcp_client.call_tool(tool_name, **params)
                return result
            except Exception as e:
                logger.error(f"Error using native MCP client for call_tool {tool_name}: {e}")
                # Fall back to HTTP implementation if error
        
        # Traditional HTTP method
        endpoint = f"api/v1/mcp/tools/{tool_name.replace('_', '-')}"
        result = await self._make_request("POST", endpoint, params)
        return result

    async def store_document(self, text: str, metadata: Optional[Dict[str, Any]] = None) -> Dict:
        """
        Store a document in MCP using the store_document tool

        Args:
            text: Text information to store
            metadata: Optional metadata for the document

        Returns:
            Storage result
        """
        return await self.call_tool("store_document", information=text, metadata=metadata or {})

    async def find_relevant(self, query: str, limit: int = 5) -> List[Dict]:
        """
        Find relevant information for a query using the find_relevant tool

        Args:
            query: Search query
            limit: Maximum number of results (default 5)

        Returns:
            List of relevant results
        """
        result = await self.call_tool("find_relevant", query=query, limit=limit)
        
        # Process results which might come in different formats
        if isinstance(result, list):
            return result
        elif isinstance(result, dict) and "results" in result:
            return result["results"]
        else:
            return [{"text": str(result)}]

    async def store_vulnerability_analysis(self, 
                                         vulnerability_id: str, 
                                         vulnerability_name: str,
                                         description: str, 
                                         mitigation: str, 
                                         severity: str,
                                         metadata: Optional[Dict[str, Any]] = None) -> Dict:
        """
        Store vulnerability analysis information in MCP

        Args:
            vulnerability_id: Unique identifier of the vulnerability
            vulnerability_name: Name or title of the vulnerability
            description: Detailed description of the vulnerability
            mitigation: Suggested mitigation steps
            severity: Severity level (high, medium, low)
            metadata: Additional metadata

        Returns:
            Storage result
        """
        # Format the vulnerability information for better context
        vulnerability_info = f"""
Vulnerability Analysis
======================
ID: {vulnerability_id}
Name: {vulnerability_name}
Severity: {severity}

Description:
{description}

Mitigation:
{mitigation}
"""

        # Prepare metadata
        meta = metadata or {}
        meta.update({
            "content_type": "vulnerability_analysis",
            "vulnerability_id": vulnerability_id,
            "vulnerability_name": vulnerability_name,
            "severity": severity
        })

        # Store using the standard store_document tool
        return await self.store_document(vulnerability_info, meta)

    async def enrich_vulnerability_with_llm(self, 
                                          vulnerability_id: str,
                                          vulnerability_name: str,
                                          description: str) -> Dict[str, Any]:
        """
        Enrich vulnerability information using LLM capabilities via MCP

        Args:
            vulnerability_id: Unique identifier of the vulnerability
            vulnerability_name: Name or title of the vulnerability
            description: Detailed description to enhance

        Returns:
            Enhanced vulnerability information
        """
        # Try to find relevant information about this vulnerability type
        relevant_info = await self.find_relevant(f"{vulnerability_name} vulnerability explanation", limit=3)
        
        # Format a prompt for the LLM to analyze
        prompt = f"""
Based on the following vulnerability information:

Name: {vulnerability_name}
ID: {vulnerability_id}
Description: {description}

And any additional information:
{relevant_info}

Please provide:
1. A more detailed explanation of this vulnerability
2. Potential impact for organizations
3. Specific mitigation recommendations
4. Detection methods
"""
        
        # In a real implementation, we'd call an LLM endpoint here
        # For now, we'll just return the structured information
        return {
            "vulnerability_id": vulnerability_id,
            "enriched": True,
            "relevant_info_count": len(relevant_info),
            "prompt": prompt
        }