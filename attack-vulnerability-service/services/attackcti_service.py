"""Service for interacting with MITRE ATT&CK via the attackcti client."""

import json
import logging
import os
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any

import attackcti
from packaging import version

from config.settings import Settings

logger = logging.getLogger(__name__)


class AttackCTIService:
    """Service for interacting with MITRE ATT&CK."""

    def __init__(self, settings: Settings):
        """Initialize the service.
        
        Args:
            settings: Application settings
        """
        self.settings = settings
        self.lift = attackcti.attack_client()
        self.cache_dir = settings.attack_cache_dir
        self.cache_ttl = settings.attack_cache_ttl_hours
        self.techniques = {}
        self.software = {}
        self.mitigations = {}
        self.cache_file = f"{self.cache_dir}/attack_data.json"
        self.last_refresh = None
        
        # Ensure cache directory exists
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # Initial data load
        self._load_or_refresh_data()
    
    def _load_or_refresh_data(self) -> None:
        """Load data from cache or refresh from MITRE ATT&CK."""
        current_time = datetime.now()
        
        # Check if cache exists and is fresh
        cache_exists = os.path.exists(self.cache_file)
        if cache_exists:
            try:
                with open(self.cache_file, 'r') as f:
                    cache_data = json.load(f)
                    self.last_refresh = datetime.fromisoformat(
                        cache_data.get('last_refresh', '2000-01-01T00:00:00')
                    )
                    self.techniques = cache_data.get('techniques', {})
                    self.software = cache_data.get('software', {})
                    self.mitigations = cache_data.get('mitigations', {})
                    
                    logger.info(
                        f"Loaded ATT&CK data from cache ({len(self.techniques)} techniques, "
                        f"{len(self.software)} software, {len(self.mitigations)} mitigations)"
                    )
            except Exception as e:
                logger.error(f"Error loading cache: {e}")
                cache_exists = False
        
        # Refresh if cache doesn't exist or is stale
        if not cache_exists or current_time - self.last_refresh > timedelta(hours=self.cache_ttl):
            self._refresh_data()
    
    def _refresh_data(self) -> None:
        """Refresh data from MITRE ATT&CK."""
        try:
            logger.info("Refreshing MITRE ATT&CK data...")
            
            # Get all techniques
            all_techniques = self.lift.get_techniques()
            self.techniques = {tech['technique_id']: tech for tech in all_techniques}
            logger.info(f"Loaded {len(self.techniques)} techniques")
            
            # Get all software
            all_software = self.lift.get_software()
            
            # Use software name as key when available, otherwise use ID
            self.software = {}
            for sw in all_software:
                key = sw.get('name', '').lower() or sw.get('software', '').lower()
                if key:
                    self.software[key] = sw
            
            logger.info(f"Loaded {len(self.software)} software entries")
            
            # Get all mitigations
            all_mitigations = self.lift.get_mitigations()
            self.mitigations = {m['mitigation_id']: m for m in all_mitigations}
            logger.info(f"Loaded {len(self.mitigations)} mitigations")
            
            # Update cache
            cache_data = {
                'last_refresh': datetime.now().isoformat(),
                'techniques': self.techniques,
                'software': self.software,
                'mitigations': self.mitigations
            }
            
            with open(self.cache_file, 'w') as f:
                json.dump(cache_data, f)
                
            self.last_refresh = datetime.now()
            logger.info(f"ATT&CK data cached to {self.cache_file}")
        except Exception as e:
            logger.error(f"Error refreshing MITRE ATT&CK data: {e}")
    
    def find_vulnerabilities_by_software(
        self, software_name: str, software_version: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Find vulnerabilities related to specific software.
        
        Args:
            software_name: Name of the software
            software_version: Version of the software
            
        Returns:
            List of vulnerabilities
        """
        results = []
        
        # Normalize software name for better matching
        software_name_lower = software_name.lower()
        
        # Create a list of potential matches based on partial name matches
        potential_matches = []
        for sw_key, sw_data in self.software.items():
            sw_name = sw_data.get('name', '').lower() or sw_data.get('software', '').lower()
            
            # Check if software name matches exactly or as substring
            if software_name_lower == sw_name or software_name_lower in sw_name:
                potential_matches.append(sw_data)
        
        for sw_data in potential_matches:
            # Get techniques related to this software
            sw_id = sw_data.get('software')
            if not sw_id:
                continue
                
            try:
                sw_techniques = self.lift.get_techniques_by_software(sw_id)
                
                for tech in sw_techniques:
                    # Skip if technique_id is missing
                    if not tech.get('technique_id'):
                        continue
                    
                    # Check if version is affected (if version specified)
                    version_affected = True
                    if software_version and 'x_mitre_version' in tech:
                        version_affected = self._version_is_affected(
                            software_version, tech.get('x_mitre_version', '')
                        )
                    
                    if not version_affected:
                        continue
                    
                    # Generate a unique ID for this vulnerability
                    vuln_id = str(uuid.uuid4())
                    
                    # Get mitigations for technique
                    mitigation_text = self._get_mitigations_for_technique(tech.get('technique_id'))
                    
                    # Reference URL for ATT&CK technique
                    reference_url = f"https://attack.mitre.org/techniques/{tech.get('technique_id')}"
                    
                    # Determine severity based on sophistication and impact
                    severity = "medium"  # Default
                    if "sophisticated" in tech.get('technique_description', '').lower():
                        severity = "high"
                    elif "difficult to detect" in tech.get('technique_description', '').lower():
                        severity = "high"
                    
                    # Create vulnerability record
                    vulnerability = {
                        'id': vuln_id,
                        'title': f"{tech.get('technique', 'Unknown Technique')} ({tech.get('technique_id', 'T0000')})",
                        'description': tech.get('technique_description', ''),
                        'severity': severity,
                        'confidence': 0.8,  # Default confidence score
                        'affected_software': sw_data.get('name') or sw_data.get('software'),
                        'affected_version': tech.get('x_mitre_version', 'All versions'),
                        'mitre_technique_id': tech.get('technique_id'),
                        'mitre_technique_name': tech.get('technique'),
                        'mitre_tactic': tech.get('tactic', ''),
                        'mitigation': mitigation_text,
                        'reference_urls': [reference_url]
                    }
                    
                    results.append(vulnerability)
            except Exception as e:
                logger.error(f"Error getting techniques for software {sw_id}: {e}")
        
        return results
    
    def _version_is_affected(self, installed_version: str, affected_versions: str) -> bool:
        """Check if installed version is affected by vulnerability.
        
        Args:
            installed_version: Version of installed software
            affected_versions: Version string from ATT&CK (e.g., "<=2.3.4, >=1.0")
            
        Returns:
            True if the installed version is affected
        """
        # If affected_versions is empty or "all versions", assume affected
        if not affected_versions or "all version" in affected_versions.lower():
            return True
        
        # Normalize installed version
        try:
            installed = version.parse(installed_version)
        except:
            # If version cannot be parsed, assume affected
            return True
        
        # Split into version constraints
        constraints = [v.strip() for v in affected_versions.split(',')]
        
        # Check each constraint
        for constraint in constraints:
            if constraint.startswith('<='):
                try:
                    max_version = version.parse(constraint[2:])
                    if installed <= max_version:
                        return True
                except:
                    continue
            elif constraint.startswith('<'):
                try:
                    max_version = version.parse(constraint[1:])
                    if installed < max_version:
                        return True
                except:
                    continue
            elif constraint.startswith('>='):
                try:
                    min_version = version.parse(constraint[2:])
                    if installed >= min_version:
                        return True
                except:
                    continue
            elif constraint.startswith('>'):
                try:
                    min_version = version.parse(constraint[1:])
                    if installed > min_version:
                        return True
                except:
                    continue
            elif constraint.startswith('=='):
                try:
                    exact_version = version.parse(constraint[2:])
                    if installed == exact_version:
                        return True
                except:
                    continue
            else:
                # If no operator, assume exact match
                try:
                    exact_version = version.parse(constraint)
                    if installed == exact_version:
                        return True
                except:
                    continue
        
        # No constraints matched
        return False
    
    def _get_mitigations_for_technique(self, technique_id: str) -> str:
        """Get mitigation recommendations for a technique.
        
        Args:
            technique_id: MITRE ATT&CK technique ID
            
        Returns:
            Mitigation text
        """
        try:
            mitigations = self.lift.get_mitigations_by_technique(technique_id)
            if mitigations:
                return "; ".join([m.get('mitigation_description', '') for m in mitigations])
        except Exception as e:
            logger.error(f"Error getting mitigations for technique {technique_id}: {e}")
        
        return "No specific mitigations available"
    
    def get_technique_details(self, technique_id: str) -> Dict[str, Any]:
        """Get detailed information about a technique.
        
        Args:
            technique_id: MITRE ATT&CK technique ID
            
        Returns:
            Technique details
        """
        if technique_id in self.techniques:
            return self.techniques[technique_id]
        
        # If not in cache, try to get it directly
        try:
            technique = self.lift.get_technique_by_technique_id(technique_id)
            if technique:
                return technique
        except Exception as e:
            logger.error(f"Error getting technique {technique_id}: {e}")
        
        return {}